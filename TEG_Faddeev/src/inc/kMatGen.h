#ifndef KMATGEN
#define KMATGEN

#include <complex>
#include <iostream>
#include <tgmath.h>
#include <string>
#include "math.h"

#include "def.h"
#include "msg.h"
#include "gaussIntegral.h"
#include "spline.h"
#include "gAndG.h"
#include "tMat.h"
#include "channels.h"
#include "matOperator.h"
#include "delta.h"

// #include "mathFunc.h"
// #include "timer.h"

// Maximal number of 3N channels handled by class kMatrix
#define _MAX_3NCHN_ 100
#define _MAX_ITER_ 50
#define _MAX_PQMSH_ 500
#define _MAX_XMSH_ 50
#define _MAX_AUXMSH_ 1000

using namespace std;

const size_t _SIZE_MB_ = 1024*1024;
const size_t _SIZE_GB_ = 1024*1024*1024;

template <class CR>
class kMatrix
{
// Equation numbers refer to codenote [January 21, 2021]

// Data structures to be initialized:
// channel, GqqxTable, intzTable_Hmgns, intzTable_Inhmgns, alphabarArray

  protected:
  CR *kMat = NULL;
  size_t NP, NQ, NX, NAuxMesh, nChannels, dimKMat;
  REAL CTanMesh, avg_mN = _AvgMassN_;
  /* channels[i][j] = the j-th quantum number of the i-th channel. i corresponds
  to the storage order of the channel in 2D array channels, *not* to be confused
  with the integer label generated by Chs::genChs()
  */
  REAL **channels = NULL;
  // REAL channels[_MAX_3NCHN_][_MAX_3NCHN_] {0.0};

  // idx_alpha, idx_alphabar are 3N-channel index, e.g., channels[idx_alpha]
  // If idx_alpha and idx_alphabar are coupled through 2N forces,
  //   alphabarArray[idx_alpha] = idx_alphabar;
  // if idx_alpha is uncoupled through its 2N subsystem,
  //   alphabarArray[idx_alpha] = -1
  // int *alphabarArray = NULL;
  int alphabarArray[_MAX_3NCHN_] {0};

  // intzTable_Hmgns and kMat
  // share the same storage pattern but have different content
  CR ***GqqxTable = NULL, *intzTable_Hmgns = NULL, *intzTable_Inhmgns = NULL;
  bool GTableAllocFlag {false}, AuxMeshSetFlag {false}, xmeshFlag {false},
    pmeshFlag {false}, qmeshFlag {false};

  REAL opJ;
  std::string potName;

  REAL xn[_MAX_XMSH_], wxn[_MAX_XMSH_],
    pn[_MAX_PQMSH_], wpn[_MAX_PQMSH_],
    qn[_MAX_PQMSH_], wqn[_MAX_PQMSH_],
    pn_aux[_MAX_AUXMSH_], wpn_aux[_MAX_AUXMSH_];
  REAL *spln_coe1 {NULL}, *spln_coe2 {NULL}, *spln_coe3 {NULL};
    // spln_coe1[_MAX_PQMSH_ * (_MAX_PQMSH_ - 1)],
    // spln_coe2[_MAX_PQMSH_ * (_MAX_PQMSH_ - 1)],
    // spln_coe3[_MAX_PQMSH_ * (_MAX_PQMSH_ - 1)];
  CR PF_pn[_MAX_AUXMSH_];

  // t_Nd --> drv_term (driving term)
  // size_t dimtNd;
  CR *tNd_tildeT {NULL}, *tNd_omega {NULL}; //t_Nd for Inhomogeneous equation
  CR *tilde_T = NULL;
  CR *TAMP_omega = NULL;

  CR Pi_1_array[_MAX_PQMSH_ * _MAX_XMSH_] {0.0},
    Pi_2_array[_MAX_PQMSH_ * _MAX_XMSH_] {0.0};
  bool flag_Pis_array_set {false};

  // CR *omega_1_array {NULL}, *omega_2_array {NULL};
  CR omega_1_array[_MAX_PQMSH_*_MAX_XMSH_] {0.0},
    omega_2_array[_MAX_PQMSH_*_MAX_XMSH_] {0.0};
  bool flag_omegas_array_set {false};

  CR mNE_qr_array[_MAX_PQMSH_];
  bool flag_mNE_array_set {false};

  CR h2wf_tNd[2*_MAX_PQMSH_*_MAX_XMSH_] {0.0};
  bool flag_h2wf_tNd_set {false};

  CR facCntr {1.0}; // contour variable: q -> facCntr * q
  bool flag_facCntr_set {false};

  int numPara2B {1};
  // physics paras maybe needed by two-body pots
  double para_2B[NUM_PARA_TWOBODY] {0.0};

  public:
  /* partner two-body coupled channels must be included simultaneously. E.g., if
  {3S1, lambda, I} is included, so must be {3D1, lambda, I}.
  */
  kMatrix(size_t _nChannels, REAL _CTanMesh, REAL **_channels, REAL _opJ)
    : nChannels(_nChannels), CTanMesh(_CTanMesh), opJ(_opJ) {

    if (_nChannels > _MAX_3NCHN_) {
      show_message_fdv("ERROR (kMatrix::kMatrix): nChannels = "
        + to_string(_nChannels) + " exceeds the limit of "
        + to_string(_MAX_3NCHN_), _VBSLVL_URGENT_);
    }

    channels = alloc_3Nchn_table(_nChannels);
    copy_3Nchn_table(_nChannels, _channels, channels);
    genAlphabarArray();

    show_message_fdv("-->kMatrix::kMatrix: CTanMesh = "
      + to_string(CTanMesh), _VBSLVL_NORMAL_);

  };

  kMatrix(const kMatrix &other)
  {
    printf("ERROR: COPY IS FORBBIDDEN"); abort();
  }; // Copy is forbidden
  ~kMatrix();

  void loadTwoBodyPara(int _numPara, double* _para)
  {
    numPara2B = _numPara;
    for (int ii = 0; ii < _numPara; ii++) para_2B[ii] = _para[ii];
  }

  void setFacContour(CR _facCntr) {
    facCntr = _facCntr;
    flag_facCntr_set = true;
    show_message_fdv("-->kMatrix::setFacContour: phi = "
      + to_string(arg(facCntr)/M_PI*180.0), _VBSLVL_LOW_);
  };

  CR FacContour() {
    return facCntr;
  };

  // Set the mesh parameters
  void setNP(size_t _NP);
  void setNQ(size_t _NQ);
  void setNX(size_t _NX);
  void setNAuxMesh(size_t _nmesh);
  void setMass(REAL _avg_mN){avg_mN = _avg_mN;};
  void setPotName(string _potName);
  REAL getMass(){return avg_mN;};
  REAL getopJ(){return opJ;};

  // (alpha pk ql; alphapp pm qn) --> 1D index
  inline size_t serialIdxKMat(size_t idx_alpha, size_t pk, size_t ql,
    size_t idx_alphapp, size_t pm, size_t qn) const {

    size_t loc = serialIdx_by_alphaPQ(idx_alpha, pk, ql)*dimKMat
      + serialIdx_by_alphaPQ(idx_alphapp, pm, qn);
    if (loc < dimKMat*dimKMat) {
      return loc;
    } else {
      cout << "ERROR kMatrix::serialIdxKMat: out of range. " << loc << " >= "
        << dimKMat*dimKMat << endl;
      return 0;
    }
  };

  inline size_t serialIdx_by_alphaPQ(size_t idx_alpha, int pk, int qr) const {

    size_t loc = idx_alpha*NP*NQ + pk*NQ + qr;
    if (loc < dimKMat) {
      return loc;
    } else {
      cout << "ERROR kMatrix::serialIdx_by_alphaPQ: out of range. " << loc << " >= "
        << dimKMat << endl;
      return 0;
    }
  };

  inline size_t serialIdx_by_alphaQX(size_t idx_alpha, int qr, int xh) const {

    size_t loc = idx_alpha*NQ*NX+qr*NX+xh;

    if (loc < nChannels*NQ*NX) {
      return loc;
    } else {
      cout << "ERROR kMatrix::serialIdx_by_alphaQX: out of range. " << loc << " >= "
        << nChannels*NQ*NX << endl;
      return 0;
    }
  };

  // SerialIdx = qr*NX + xh (serializing NQ-by-NX matrix index)
  inline size_t serialIdx_by_QX(size_t qr, int xh) const {

    size_t loc = qr*NX + xh;
    if (loc < NQ*NX) {
      return loc;
    } else {
      cout << "ERROR kMatrix::serialIdx_by_alphaQX: out of range. " << loc << " >= "
        << nChannels*NQ*NX << endl;
      return 0;
    }
  };

  // SerialIdx = ql*NP + pk (serializing NP-by-NQ matrix index)
  void mapSerialIdxToPQ(size_t SerialIdx, size_t& pk, size_t& ql) const {
    pk = SerialIdx / NP;
    ql = SerialIdx % NP;
  };
  // SerialIdx = qr*NX + xh (serializing NQ-by-NX matrix index)
  void mapSerialIdxToQX(size_t SerialIdx, size_t& qr, size_t& xh) const {
    qr = SerialIdx / NX;
    xh = SerialIdx % NX;
  };
  void allocKMat();     // Allocate memory for kMat
  void initKMatUnit();  // Initialize kMat with identity matrix

  void setSplineCoefs(); // generate spline coefficients

  void genGTable();
  void deallocGTable();

  void genAlphabarArray();
  void genPiArrays(REAL q0);
  void gen_mNE_qr_array(CR E3);
  void gen_omega_arrays(REAL q0_p);
  CR gen_h2wf_tNd();
  void genIntzTable_Hmgns();
  void genIntzTable_Inhmgns(CR energy);

  CR gen_deutwf_generic(size_t NPi, CR *Pi, CR *wfArray);
  tMatrix<CR>* tmat_2body(REAL *alpha, size_t n_mNE, CR* mNE_lst,
    size_t n_pp, CR* pp_lst, size_t n_p,  CR* p_lst);

  // void gen_tNd_phi(REAL q0, CR phi_ld []);

  void gen_PInvG0_phi_initial(REAL q0, REAL q0_p, CR phi_ld []);
  void gen_PInvG0_phi_final(REAL q0, REAL q0_p, CR phi_ld []);

  CR intz_Hmgns(REAL lpinp, REAL alpha[], REAL alphapp[], CR *GArray,
    size_t& i, size_t& m, size_t& l, size_t& n);

  void setKMatSnglAlpha(CR E3CM, REAL mN,
    size_t idx_alpha, size_t idx_alphapp,
    tMatrix<CR>& tMat, bool Inh); // If Inh = true, works for inhomo. eqn.

  void genKMat_generic(CR E3CM, REAL mN, bool Inh);//if Inh=true, generate KMat_Inhmgns
  void genKMat_Hmgns(CR E3CM, REAL mN){genKMat_generic(E3CM,  mN, false);} // Generate KMat

  // [Eq.(21)]
  void genKMat_Inhmgns(CR E3CM, REAL mN){genKMat_generic(E3CM, mN, true);}

  CR findKHmgnsDetFunc(CR energyLoc);
  REAL findBE(REAL, REAL, REAL, std::string str = "Secant"); // Find the binding energy
  REAL findZeroReDetK(REAL ReE0, REAL ReE1, REAL ImE, REAL error, COMPLEX &det);

  unsigned int IterFindZero {0};
  COMPLEX findResPole(REAL ReE0, REAL ReE1, REAL ImE0, REAL ImE1, REAL errorRe, REAL errorIm,
    COMPLEX &finalDetK);

  CR findKInhmgnsDetFunc(REAL energyLoc);
  CR intz_Inhmgns(CR E3CM, REAL mN, REAL lpinp, REAL alpha[], REAL alphapp[], CR *GArray,
    size_t& i, size_t& m, size_t& l, size_t& n);

  void gen_tNd_tildeT(CR E3, REAL q0, REAL lambda, REAL I);
  void gen_tNd_omega(CR E3, REAL q0_p, REAL q0, REAL lambda, REAL I);

  void gen_tilde_T(CR energyLoc, REAL q0, REAL  input_lamda, REAL  input_I);

  void genTAMP_omega(CR E3CM, REAL mN, REAL q0_p, REAL q0, REAL  input_lamda, REAL  input_I);

  CR get_PInvG0(REAL energyLoc, REAL q0_p, REAL input_lamdap, REAL input_Ip, REAL q0, REAL input_lamda, REAL input_I);

  CR get_PT(REAL energyLoc, REAL q0_p,  REAL input_lamdap, REAL input_Ip, REAL q0, REAL input_lamda, REAL input_I);

  // CR get_U(REAL energyLoc, REAL q0_p,  REAL input_lamdap, REAL input_Ip,
  // REAL q0, REAL input_lamda, REAL input_I);

  CR get_U_elastic(REAL q0, REAL lambda_prime, REAL I_prime, REAL lambda, REAL I);

  void get_U_array(REAL parity_, REAL q0, CR * U_array);


};

template <class CR>
kMatrix<CR>::~kMatrix()
{

  dealloc_3Nchn_table(nChannels, channels);
  deallocGTable();
  delete[] GqqxTable;
  delete[] spln_coe1;
  delete[] spln_coe2;
  delete[] spln_coe3;

  delete[] intzTable_Hmgns;
  delete[] intzTable_Inhmgns;
  delete[] kMat;
  delete[] tNd_tildeT;
  delete[] tNd_omega;
  delete[] tilde_T;
  delete[] TAMP_omega;
}

template <class CR>
void kMatrix<CR>::initKMatUnit()
{
  for(size_t idx = 0; idx < dimKMat * dimKMat; ++idx){
    if(idx % (dimKMat + 1) == 0)
      kMat[idx] = 1;
    else
      kMat[idx] = 0;
  }
}

template <class CR>
void kMatrix<CR>::allocKMat()
{
  dimKMat = NP * NQ * nChannels;
  show_message_fdv("-->kMatrix::allocKMat: dimKMat = " + to_string(dimKMat),
    _VBSLVL_HIGH_);
  show_message_fdv("-->kMatrix::allocKMat: about to alloc MEM (GB) " + to_string( double(dimKMat*dimKMat*sizeof(CR))/(_SIZE_GB_) ), _VBSLVL_HIGH_);

  delete[] kMat;
  kMat = new CR [dimKMat * dimKMat];

  show_message_fdv("-->kMatrix::allocKMat: ends ",
    _VBSLVL_HIGH_);

}

template <class CR>
void kMatrix<CR>::setNX(size_t _NX)
{
  if (_NX > _MAX_XMSH_) {
    show_message_fdv("ERROR (kMatrix::setNX): NX = "
      + to_string(_NX) + " exceeds the limit of "
      + to_string(_MAX_XMSH_), _VBSLVL_URGENT_);
  }
  NX = _NX;
  show_message_fdv("-->kMatrix::setNX: NX = " + to_string(NX), _VBSLVL_LOW_);
  createGauss(xn, wxn, NX, -1.0, 1.0);
  xmeshFlag = true;
}

template <class CR>
void kMatrix<CR>::setNP(size_t _NP)
{
  if (_NP > _MAX_PQMSH_) {
    show_message_fdv("ERROR (kMatrix::setNP): NP = "
      + to_string(_NP) + " exceeds the limit of "
      + to_string(_MAX_PQMSH_), _VBSLVL_URGENT_);
  }
  NP = _NP;
  show_message_fdv("-->kMatrix::setNP: NP = " + to_string(NP), _VBSLVL_LOW_);
  createGaussInf(pn, wpn, NP, CTanMesh);
  setSplineCoefs();
  pmeshFlag = true;

  if (! flag_facCntr_set) {
    cout << "ERROR (kMatrix::setNP): contour phase factor not set";
  }
  for (size_t i = 0; i < NP; i++) {
    PF_pn[i] = facCntr*pn[i];
  }
}

template <class CR>
void kMatrix<CR>::setSplineCoefs() {

  delete[] spln_coe1;
  delete[] spln_coe2;
  delete[] spln_coe3;
  spln_coe1 = new REAL[NP * (NP-1)];
  spln_coe2 = new REAL[NP * (NP-1)];
  spln_coe3 = new REAL[NP * (NP-1)];
  genSplineCoefs(spln_coe1, spln_coe2, spln_coe3, pn, NP);
}

template <class CR>
void kMatrix<CR>::setNQ(size_t _NQ) {
  if (_NQ > _MAX_PQMSH_) {
    show_message_fdv("ERROR (kMatrix::setNQ): NQ = "
      + to_string(_NQ) + " exceeds the limit of "
      + to_string(_MAX_PQMSH_), _VBSLVL_URGENT_);
  }
  NQ = _NQ;
  show_message_fdv("-->kMatrix::setNQ: NQ = " + to_string(NQ), _VBSLVL_LOW_);
  createGaussInf(qn, wqn, NQ, CTanMesh);
  qmeshFlag = true;
}

template <class CR>
void kMatrix<CR>::setNAuxMesh(size_t _NAuxMesh) {
  if (_NAuxMesh > _MAX_AUXMSH_) {
    show_message_fdv("ERROR (kMatrix::setNAuxMesh): NAuxMesh = "
      + to_string(_NAuxMesh) + " exceeds the limit of "
      + to_string(_MAX_AUXMSH_), _VBSLVL_URGENT_);
  }
  NAuxMesh = _NAuxMesh;
  show_message_fdv("-->kMatrix::setNAuxMesh: NAuxMesh = " + to_string(NAuxMesh),
    _VBSLVL_LOW_);
  createGaussInf(pn_aux, wpn_aux, NAuxMesh, CTanMesh);
  AuxMeshSetFlag = true;
}

template <class CR>
void kMatrix<CR>::setPotName(string _potName) {
  potName = _potName;
  show_message_fdv("-->kMatrix::setPotName: potName = " + potName,
    _VBSLVL_LOW_);
}

// Initialize alphabarArray[] once channels is initialized
template <class CR>
void kMatrix<CR>::genAlphabarArray() {

  size_t i, j;

  for (i = 0; i < nChannels; i++) {
    bool NotFoundCpld {true};
    for (j = 0; j < nChannels; j++) {
      if (is2BChnCoupled(channels[i], channels[j])) {
        alphabarArray[i] = j;
        NotFoundCpld = false;
      }
    }
    if (NotFoundCpld) {
      alphabarArray[i] = -1;
    }
  }

  for (i = 0; i < nChannels; i++) {
    if (alphabarArray[i] != -1) {
      if (i != (size_t) alphabarArray[alphabarArray[i]]) {
        cout << "-->kMatrix::genAlphabarArray: inconsistency found for channel " << i
          << " and " << alphabarArray[i] << endl;
      }
    }
  }
}

template <class CR>
void kMatrix<CR>::deallocGTable() {

  if (! GTableAllocFlag) {
    return;
  }

  for(size_t i = 0; i < nChannels; i++){
    for (size_t j = 0; j < nChannels; j++) {
      delete[] GqqxTable[i][j];
    }
    delete[] GqqxTable[i];
  }

  GTableAllocFlag = false;
}

/*
Generate G_{alphabar, alpha''}(qr, qn, xh) for all 3N-channels and q, x meshs
Prerequisite: channels, nChannels, q, x mesh
*/
template <class CR>
void kMatrix<CR>::genGTable() {

  show_message_timestamp_fdv("-->kMatrix::genGTable: begins", _VBSLVL_HIGH_);
  show_message_fdv("-->kMatrix::genGTable -> to alloc MEM (MB) "
    + to_string(double(NQ*NQ*NX*nChannels*nChannels*sizeof(CR))/(_SIZE_MB_)),
    _VBSLVL_HIGH_);

  deallocGTable();
  delete[] GqqxTable;
  // GqqxTable[idx_alpha][idx_alphapp] -> GArray
  GqqxTable = new CR **[nChannels];
  for (size_t i = 0; i < nChannels; i++) {
    GqqxTable[i] = new CR *[nChannels];
    for (size_t j = 0; j < nChannels; j++) {
      GqqxTable[i][j] = new CR[NQ * NQ * NX];
      GArrayGen(facCntr, NQ, qn, NX, xn, channels[i], channels[j], GqqxTable[i][j]);
    }
  }

  GTableAllocFlag = true;
  show_message_timestamp_fdv("-->kMatrix::genGTable: ends", _VBSLVL_HIGH_);
}

template <class CR>
void kMatrix<CR>::genKMat_generic(CR E3CM, REAL mN, bool Inh){

  if (! flag_mNE_array_set) {
    show_message_fdv("ERROR (kMatrix::genKMat_generic): mNE_qr_array not ready",
      _VBSLVL_LOW_);
    return;
  }
  show_message_timestamp_fdv("-->kMatrix::genKMat_generic: begins",
    _VBSLVL_LOW_);

  // Storage location of channel alpha and alpha'' in channels[][]
  size_t idx_alpha {0}, idx_alphapp {0};
  /* alpha[]: quantum numbers of channel alpha
     alphapp[]: quantum numbers of channel alphapp
     see macro definitions in channels.h for physical meaning of each element
  */

  // debug
  if (! GTableAllocFlag) {
    cout << "-->kMatrix::genKMat_generic: GTable not ready!" << endl;
  }

  allocKMat();
  initKMatUnit();
  for(idx_alpha = 0; idx_alpha < nChannels; idx_alpha ++){

    int intL, intS, intJ;
    intL = (int) channels[idx_alpha][_CHNIDX_l_]; // L
    intS = (int) channels[idx_alpha][_CHNIDX_s_]; // S
    intJ = (int) channels[idx_alpha][_CHNIDX_j_]; // J (I)
    tMatrix<CR> tMat (intL, intS, intJ, NQ, NP);
    tMat.setFacContour(facCntr);
    tMat.copyMEArray(mNE_qr_array);
    tMat.setPotName(potName);
    tMat.loadPotPara(numPara2B, para_2B);
    tMat.chengduT(pn, wpn);

    for(idx_alphapp = 0; idx_alphapp < nChannels; idx_alphapp++) {
      setKMatSnglAlpha(E3CM, mN, idx_alpha, idx_alphapp, tMat, Inh);
    }
  }

  show_message_timestamp_fdv("-->kMatrix::genKMat_generic: ends",
    _VBSLVL_LOW_);
}

/*
Fill out subset of homogeneous or inhomogeneous kMat elements that have given
alpha and alphapp [Eqs.(11) and (21)]
 */
template <class CR>
void kMatrix<CR>::setKMatSnglAlpha(CR E3CM, REAL mN,
  size_t idx_alpha, size_t idx_alphapp, tMatrix<CR>& tMat, bool Inh){

  REAL lprime[2] = {channels[idx_alpha][_CHNIDX_l_],
    channels[idx_alpha][_CHNIDX_lcpld_]};

  #pragma omp parallel for
  for (size_t idx_kr = 0; idx_kr < NP*NQ; idx_kr++) {

    size_t k, r;
    mapSerialIdxToPQ(idx_kr, k, r);

    CR fctr_kr;
    if (Inh) {
      fctr_kr = 1.0;
    } else {
      fctr_kr = 1.0/(E3CM-facCntr*facCntr*(pn[k]*pn[k]/mN+0.75*qn[r]*qn[r]/mN));
    }

    size_t nch_2body = tMat.readNCH();
    for (size_t idx_lprime=0; idx_lprime < nch_2body; idx_lprime++) { // Loop of l prime
      for (size_t i=0; i<NP; i++) { // Loop of i
        CR tMatFactor = tMat.readTMat_Mat(channels[idx_alpha][_CHNIDX_l_], lprime[idx_lprime],
          k, i, r, channels[idx_alpha][_CHNIDX_l_], channels[idx_alpha][_CHNIDX_lcpld_]);
        // Skip if the tMat element is smaller than _tMat_ZERO_ */
        // if ( abs(tMatFactor) < _tMat_ZERO_ ) continue;
        for (size_t m = 0; m < NP; m++) {
          for (size_t n = 0; n < NQ; n++) {
            CR fctr_lnim;
            size_t idx_alphabar = (idx_lprime == 0 ? idx_alpha : alphabarArray[idx_alpha]);
            if (Inh) {
              fctr_lnim = tMatFactor*intzTable_Inhmgns[serialIdxKMat(
                idx_alphabar, i, r, idx_alphapp, m, n)];
            } else {
              fctr_lnim = tMatFactor*intzTable_Hmgns[serialIdxKMat(
                idx_alphabar, i, r, idx_alphapp, m, n)];
            }
            size_t sumIdx = serialIdxKMat(idx_alpha, k, r, idx_alphapp, m, n);
            kMat[sumIdx] -= pow(facCntr, 3)*fctr_kr*wqn[n]*qn[n]*qn[n]*fctr_lnim;
          }
        }
      }
    }
  }
}

/*
E3 : 3-body CM energy
Fill out mNE_qr_array[r] = mN * E3 - 3/4 f^2 qn[r]^2 [Eqs.(8), (21)]
*/
template <class CR>
void kMatrix<CR>::gen_mNE_qr_array(CR E3) {

  if (! qmeshFlag) {
    cout << "kMatrix::gen_mNE_qr_array: q-mesh not ready" << endl;
    return;
  }

  for (size_t i = 0; i < NQ; i++) {
    mNE_qr_array[i] = avg_mN * E3 - 0.75*facCntr*facCntr * qn[i] * qn[i];
  }
  flag_mNE_array_set = true;
}

/*
Compute all U_lambda_I [on the r.h.s. of Eq.(40)] needed by S matrix, and stores
them in certain order which is decided by function get_Upara_list in delta.h.
*/
template <class CR>
void kMatrix<CR>::get_U_array(REAL parity_, REAL q0, CR * U_array){

  REAL parity = abs(parity_)<_momentum_EPS_?1.0:-1.0;
  for(REAL lambda_p = min(abs(opJ-1.5),abs(opJ-0.5)); lambda_p <= opJ+1.5; lambda_p+=1.0){
    if(abs(pow(-1.0,lambda_p)-parity) > _momentum_EPS_ )
      continue;
    REAL minI_p = max(abs(lambda_p-0.5) , abs(1.0-opJ));
    REAL maxI_p = min(abs(lambda_p+0.5), abs(1.0+opJ));
    for(REAL I_p = minI_p; I_p <= maxI_p; I_p+=1.0){
      for(REAL lambda = min(abs(opJ-1.5),abs(opJ-0.5)); lambda <= opJ+1.5; lambda+=1.0){
        if(abs(pow(-1.0,lambda)-parity) > _momentum_EPS_ )
          continue;
        REAL minI = max(abs(lambda-0.5) , abs(1.0-opJ));
        REAL maxI = min(abs(lambda+0.5) , abs(1.0+opJ));
        for(REAL I = minI; I <= maxI; I+=1.0){
          U_array[SerialofIdx_U_list(opJ, lambda_p, I_p, lambda, I)] = get_U_elastic(q0,lambda_p,I_p,lambda,I);
        }
      }
    }
  }
}

#include "kmathmgns.tpp"
#include "kmatinh.tpp"

#endif
